This Could Be Better Game Framework Development Guide
=====================================================

This guide illustrates the creation of a new game from scratch using the This Could Be Better Game Framework.

First, we need to create a new game based on the stub game.  Download a copy of the GameFrameworkTS repository by running this command:

	git clone https://github.com/thiscouldbebetter/GameFrameworkTS

Then, within the repository, locate the "Source/Stub" directory.

Copy the contents the Stub directory to any convenient locatation outside of the original GameFrameworkTS repository.

Now we need to decide what to call our new game.  Let's make a clone of the classic arcade game Defender, in which the player controls a spaceship tasked with protecting the population of a planet from alien abduction.  Rename the Stub directory to "DefenderClone".

In the newly renamed DefenderClone directory, open the Source directory.

In the Source directory, rename the file "GameStub.html" to "DefenderClone.html".

Still in the Source directory, open the file "Game.ts" in a text editor, locate the call to Universe.create(), change the first argument from "GameStub" to "DefenderClone", and save.  This string will be used to name any saved game files.

Most of the gameplay in classic arcade games take place on "levels", so let's rename the PlaceStub class accordingly.  Still in the Source directory, rename the file "PlaceStub.ts" to "PlaceLevel.ts".

Open the newly renamed file PlaceLevel.ts in a text editor, replace all instances of the text "PlaceStub" with "PlaceLevel", and save.

Still in the Source directory, open the file "WorldGame.ts" in a text editor.  Locate the constructor, and change the first argument to the super() constructor from "GameStub" to "DefenderClone".  Replace all instances of the text "PlaceStub" with "PlaceLevel".  Save the file.

From the Source directory, run the command "tsc" to compile the program.  Wait for the command to complete, and verify that no errors are displayed.

Open the file DefenderClone.html in a web browser that runs JavaScript.  Click the "Start" button on the opening and title screens to dismiss 
 them, then click the "Skip" button.  A black screen will displayed.  If you'd like, you can press the Escape key to see some game and settings menus.

That blank void is pretty boring.  Let's add some ground.

First, we'll add a class to represent it.  But before that, we'll need somewhere to put that class file.  Within the Source directory, create a new directory named "Model".

Within the newly created Model directory, create a new file named "Planet.ts", containing the text below:

	class Planet extends Entity
	{
		constructor(name: string, size: Coords, horizonHeight: number)
		{
			super
			(
				name,
				[
					Drawable.fromVisual
					(
						VisualRectangle.fromSizeAndColorFill
						(
							Coords.fromXY(size.x, horizonHeight),
							Color.Instances().GreenDark
						)
					),

					Locatable.fromPos
					(
						Coords.fromXY(size.x / 2, size.y - horizonHeight / 2)
					),
				]
			);
		}
	}

Back in the Source directory, open the file PlaceLevel.ts in a text editor.  Locate the constructor, and within it, the array being passed as the "entities" argument of the super() constructor.  Within that array, add the following text, then save the file.

	new Planet("Planet0", Coords.fromXY(400, 300), 50),

From the Source directory, run the command "tsc" to compile the program.  Wait for the command to complete, and verify that no errors are displayed.

In the web browser, refresh DefenderClone.html and start the game again.  Verify that a green field, representing the ground, appears at the bottom of the screen.

Now there's some ground, but ground by itself is almost as boring as a void.  Let's add a spaceship.  For that, we'll need another class file.

Back in the Model directory, create a new file name "Ship.ts", containing the text below:

	class Ship extends Entity
	{
		constructor(name: string, pos: Coords)
		{
			super
			(
				name,
				[
					Drawable.fromVisual
					(
						VisualPolygon.fromVerticesAndColorFill
						(
							[
								Coords.fromXY(-5, -5),
								Coords.fromXY(5, 0),
								Coords.fromXY(-5, 5),
							],
							Color.Instances().Gray
						)
					),

					Locatable.fromPos(pos),
				]
			);
		}
	}

The new Ship class is a subclass of Entity, and it has two properties, namely, Drawable and Locatable.  An instance of Drawable represents something that can be drawn to the screen, while an instance of Locatable represents something that has a specific position and orientation (and, incidentally, velocity and acceleration, among other things).

Now that the Ship class is defined, let's create an instance of it and add it to the entity collection of our PlaceLevel instance.  Back in the Source directory, open the file PlaceLevel.ts in a text editor again.  Within the array being passed as the "entities" argument of the super() constructor, add the following text, then save the file.

	new Ship("Ship0", Coords.fromXY(100, 100))

Compile the program again, then refresh DefenderClone.html and start the game.  A gray triangle pointing right, representing a spaceship, now appears above the ground.

Now there's a spaceship, which should be exciting.  But it doesn't move.  So it's still pretty boring.  Let's make it move.

To make it move, we'll assign it a velocity to go along with its position.  Open Ship.ts in a text editor and replace the line "Locatable.fromPos(pos)" with the following text:

	new Locatable
	(
		Disposition.fromPosAndVel
		(
			Coords.fromXY(100, 100), // pos
			Coords.fromXY(1, 0) // vel
		)
	)

Compile the program again, then refresh DefenderClone.html and start the game.  The same gray, triangular spaceship still appears, but now it... still doesn't move.  What gives?  Well, the problem is that, while the Ship entity does have a Locatable property, it's being ignored.  It SHOULD be being updated every tick of the game timer.  To make that happen, we need to add Locatable to the list of properties that the PlaceLevel updates every tick.

To make sure that Locatables are being processed every timer tick, open PlaceLevel.ts in a text editor, locate the static defnBuild() method within it, and replace the line where the variable entityPropertyNamesToProcess is declared as an empty array with the following text:

	var entityPropertyNamesToProcess =
	[
		Locatable.name
	];

Compile the program again, then refresh DefenderClone.html and start the game.  The same gray, triangular spaceship still appears, but now it moves.  It moves all the way to the right side of the screen, then disappears, never to return.

This briefly makes the spaceship somewhat more interesting than when it was stationary, but once it moves off the right side of the screen, the view is even more boring that it was before.  To fix that, that, we can make the screen "wrap", so that when the spaceship moves off the right side of the screen, it reappears on the left side.  That, in turn, can be accomplished by giving the Ship entity the Constrainable property and putting a Constraint on it.

But first, we'll add Constrainable to the list of properties that the PlaceLevel updates each timer tick.  In PlaceLevel.ts, add a new line to the array of strings being assigned to the entityPropertyNamesToProcess variable, making sure to add a comma after the existing one:

	var entityPropertyNamesToProcess =
	[
		Locatable.name,
		Constrainable.name
	];

Now we'll add a Constrainable property to the Ship entity.  Open Ship.ts and, in the list of properties being passed to the super() constructor, add the following text:

	new Constrainable
	([
		new Constraint_WrapXTrimY()
	])

Now the ship wraps to stay in view continuously, so the view stays interesting.  It would be more interesting still if the ship changed speed and direction.  To make that work, we need to give it the Actor property. 

To make the game process Actor properties every timer tick, open PlaceLevel.ts and add another new line to the array of strings being assigned to the entityPropertyNamesToProcess variable, again making sure to add another comma to the entry between the old final entry and the new final entry:

	var entityPropertyNamesToProcess =
	[
		Locatable.name,
		Constrainable.name,
		Actor.name
	];

To define the ActivityDefn for the ship's behavior, open Ship.ts and add the following method:

	static activityDefnDoSpaceshipStuffBuild(): ActivityDefn
	{
		var activityDefnDoSpaceshipStuff = new ActivityDefn
		(
			"DoSpaceshipStuff",
			// perform
			(universe: Universe, world: World, place: Place, entity: Entity) =>
			{
				var placeWidthHalf = place.size.x / 2;

				var ship = entity as Ship;
				var shipLoc = ship.locatable().loc;
				var shipPos = shipLoc.pos;
				var shipOrientation = shipLoc.orientation;
				var shipForward = shipOrientation.forward;
				var shipAccel = shipLoc.accel;
				if (shipPos.x > placeWidthHalf)
				{
					shipForward.x = -1;
				}
				else
				{
					shipForward.x = 1;
				}
				shipOrientation.forwardSet(shipForward);

				var accelerationPerTick = 0.1;
				shipAccel.x = shipForward.x * accelerationPerTick;
			}
		);

		return activityDefnDoSpaceshipStuff;
	}

Now that the ActivityDefn for the Ship is defined, we want to make sure that the WorldDefn knows about it, so that it's there when the Ship entity's Actor property tries to look it up.  Open WorldGame.ts and replace the existing .defnBuild() method with the following text:

	static defnBuild(): WorldDefn
	{
		return new WorldDefn
		([
			[
				ActivityDefn.Instances().HandleUserInput,
				Ship.activityDefnDoSpaceshipStufBuild()
			],
			[
				PlaceLevel.defnBuild()
			]
		]);
	}

Finally, give the Actor property to the Ship.  In Ship.ts, add a new entry to the array of entity properties, right below the Locatable instance, again making sure to add a comma between the old Locatable declaration and the new Actor declaration:

	Actor.fromActivityDefnName("DoSpaceshipStuff")

Compile the program again, then refresh DefenderClone.html and start the game.  The spaceship now accelerates toward the right side of the screen if it's on the left half of the screen, and accelerates toward the left side of the screen if it's on the right side of the screen.

Furthermore, our spaceship faces to the right when it's accelerating right, and to the left when it's accelerating left.  Ordinarily, we'd need to modify the Visual for the Ship for this to work, but since we're using a VisualPolygon, it automatically transforms the visual based on the Ship's orientation.  And we already added the code to set the Ship's orientation, in the same place where we're setting the acceleration, that is, in Ship.activityDefnDoSpaceshipStuffBuild().  Nice!
